using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text.Json;
using System.Threading; // Added for CancellationToken
using System.Threading.Tasks;

namespace CyberShield_V3.Services
{
    public class MalwareBazaarClient
    {
        private readonly HttpClient _httpClient;
        private const string BASE_URL = "https://mb-api.abuse.ch/api/v1/";
        private readonly string _apiKey;

        public MalwareBazaarClient(string apiKey)
        {
            _apiKey = apiKey;
            _httpClient = new HttpClient();
            _httpClient.Timeout = TimeSpan.FromSeconds(10);

            _httpClient.DefaultRequestHeaders.Add("User-Agent", "CyberShield/1.0");
            _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");
            _httpClient.DefaultRequestHeaders.Add("Auth-Key", _apiKey);
        }

        // UPDATED: Accepts CancellationToken
        public async Task<MalwareQueryResult> QueryByHashAsync(string sha256Hash, CancellationToken token = default)
        {
            var parameters = new Dictionary<string, string>
            {
                { "query", "get_info" },
                { "hash", sha256Hash }
            };
            return await PostQueryAsync(parameters, token);
        }

        // UPDATED: Accepts CancellationToken
        public async Task<MalwareQueryResult> GetRecentSamplesAsync(int limit = 100, CancellationToken token = default)
        {
            var parameters = new Dictionary<string, string>
            {
                { "query", "get_recent" },
                { "selector", limit.ToString() }
            };
            return await PostQueryAsync(parameters, token);
        }

        // UPDATED: Passes token to HttpClient
        private async Task<MalwareQueryResult> PostQueryAsync(Dictionary<string, string> parameters, CancellationToken token)
        {
            try
            {
                using (var content = new FormUrlEncodedContent(parameters))
                {
                    // This creates the magic: If token is cancelled, this throws immediately
                    var response = await _httpClient.PostAsync(BASE_URL, content, token);

                    if (response.IsSuccessStatusCode)
                    {
                        var json = await response.Content.ReadAsStringAsync(token);
                        return ParseResponse(json);
                    }
                    return new MalwareQueryResult { Success = false, Error = "HTTP " + response.StatusCode };
                }
            }
            catch (OperationCanceledException)
            {
                // Return a specific error or rethrow. 
                // Rethrowing helps the caller know it was cancelled.
                throw;
            }
            catch (Exception ex)
            {
                return new MalwareQueryResult { Success = false, Error = ex.Message };
            }
        }

        private MalwareQueryResult ParseResponse(string jsonString)
        {
            try
            {
                using (var doc = JsonDocument.Parse(jsonString))
                {
                    var root = doc.RootElement;
                    if (root.TryGetProperty("query_status", out var statusEl))
                    {
                        string status = statusEl.GetString();
                        if (status == "ok")
                        {
                            var result = new MalwareQueryResult { Success = true };
                            if (root.TryGetProperty("data", out var data) && data.ValueKind == JsonValueKind.Array)
                            {
                                foreach (var item in data.EnumerateArray())
                                {
                                    var s = ParseSample(item);
                                    if (s != null) result.Samples.Add(s);
                                }
                            }
                            return result;
                        }
                        else if (status == "no_results" || status == "hash_not_found")
                        {
                            return new MalwareQueryResult { Success = true };
                        }
                        return new MalwareQueryResult { Success = false, Error = status };
                    }
                    return new MalwareQueryResult { Success = false, Error = "Invalid JSON" };
                }
            }
            catch { return new MalwareQueryResult { Success = false, Error = "JSON Error" }; }
        }

        private MalwareSample ParseSample(JsonElement element)
        {
            var s = new MalwareSample();
            if (element.TryGetProperty("sha256_hash", out var h)) s.Sha256Hash = h.GetString();
            if (element.TryGetProperty("signature", out var sig) && sig.ValueKind == JsonValueKind.String)
                s.MalwareFamily = sig.GetString();
            else if (element.TryGetProperty("tags", out var tags) && tags.ValueKind == JsonValueKind.Array)
            {
                foreach (var t in tags.EnumerateArray()) { s.MalwareFamily = t.GetString(); break; }
            }
            if (string.IsNullOrEmpty(s.MalwareFamily)) s.MalwareFamily = "Unknown Threat";
            return s;
        }
    }

    public class MalwareSample { public string Sha256Hash { get; set; } public string MalwareFamily { get; set; } public string MalwareName { get; set; } }
    public class MalwareQueryResult { public bool Success { get; set; } public List<MalwareSample> Samples { get; set; } = new List<MalwareSample>(); public string Error { get; set; } }
}